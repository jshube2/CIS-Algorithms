import unittest
import numpy as np
import ICPmatch as icpm
import sphere as sphere
import cov_tree_node as ctn
import triangle as tr
import sys
import math

class p4_tests(unittest.TestCase):

    def test_find_b_tip(self):
        '''
        Tests the find_b_tip method with randomly generated data.
        Output: if all assert statements pass successfully.
        '''

        print "Testing find_b_tip"
        # Random angle generation to create unique rotation matrices
        angles1 = np.random.uniform(0, 2 * np.pi, (3,))
        angles2 = np.random.uniform(0, 2 * np.pi, (3,))

        # Randomly generate rigid body LEDs and A_tip
        a_led = np.random.uniform(0, 5, (3, 10))
        b_led = np.random.uniform(0, 5, (3, 10))
        a_tip = np.random.uniform(0, 5, (3, 1))

        # Generate randomized rotation matrices
        r1 = self.get_rotation(angles1)
        r2 = self.get_rotation(angles2)

        # generate randomied translation matrices
        p1 = np.random.uniform(0, 5, (3,1))
        p2 = np.random.uniform(0, 5, (3,1))

        # calculated frames with generated rotation and translation values
        a_frames = r1.dot(a_led) + p1
        b_frames = r2.dot(b_led) + p2

        # Test if d generated by b_tip method is approximately equal
        d = np.linalg.inv(r2).dot(r1).dot(a_tip) + np.linalg.inv(r2).dot(p1 - p2)
        print "True d: " + str(d)

        # calculate test d
        test_d = icpm.icp_get_d([a_frames], [b_frames], a_led, a_tip, b_led)
        print "Calculated d: " + str(test_d)

        # check that difference in calculated d is below tolerance level
        self.assertTrue(np.all(np.abs(d - test_d) <= 0.001))

        print "find_b_tip passed successfully!"


    def get_rotation(self, angles):
        '''
        Creates a 3D rotation matrix for testing the find b_pointer method
        Inputs: angles -> the rotation angles for x, y, and z
        Output: a generated 3x3 rotation matrix, randomized for each run
        '''
        theta = angles[0]
        phi = angles[1]
        gamma = angles[2]

        # generate rotation matrix from provided angles
        rot_x = np.array([[1, 0, 0], [0, np.cos(theta), -np.sin(theta)], [0, np.sin(theta), np.cos(theta)]])
        rot_y = np.array([[np.cos(phi), 0, np.sin(phi)], [0, 1, 0], [-np.sin(phi), 0, np.cos(phi)]])
        rot_z = np.array([[np.cos(gamma), -np.sin(gamma), 0], [np.sin(gamma), np.cos(gamma), 0], [0, 0, 1]])
        # return resultant randomized rotation matrix
        return rot_x.dot(rot_y.dot(rot_z))


    def test_find_closest_point(self):
        """
        Tests the closest_point_linear function with a provided set of triangles.
        Output: if all assertion statements successfully pass
        """

        print "Testing find_closest_point"
        # set triangle coordinates and vertices
        tri_coords = np.array([[2, 2, 6], [3, 5, 4],[2, 2, 2]])
        tri_inds = np.array([[0],[1],[2]])

        # generate point to find closest point to
        s = np.array([4, 4, 4])
        # the expected resulting point
        c_expected = np.array([4, 4, 2])

        c_calc = icpm.closest_point_linear(s, tri_coords, tri_inds)
        print "Closest point: " + str(c_calc)

        # check that the expected c value is same as c_calc
        self.assertTrue(np.all(np.abs(c_expected - c_calc) <= 0.0001))

        # test a point actually inside the triangle
        s = np.array([4.5, 4, 2])
        c_expected = np.array([4.5, 4, 2])
        c_calc = icpm.closest_point_linear(s, tri_coords, tri_inds)
        print "Closest point: " + str(c_calc)

        self.assertTrue(np.all(np.abs(c_expected - c_calc) <= 0.0001))
        print "find_closest_point passed successfully!"


    def test_icp_linear(self):
        """
        Tests ICP using a series of points queried against a generated mesh. Uses a brute-force linear search.
        :param tolerance: Maximum tolerance between expected and calculated results
        :type tolerance: float
        :return: None
        """

        print "Testing closest_point_linear"
        tri_coords = np.array([[2, 4, 2],[3, 4, 5],[2, 2, 2]], dtype=np.float64)
        to_add = np.array([[4, 4, 4],[ 0, 0, 0], [0, 0, 0]], dtype=np.float64)
        # generate an array of triangle coordinates to build triangles
        for i in range(2):
            tri_coords = np.hstack((tri_coords, tri_coords[:, (-3, -2, -1)] + to_add))

        print 'Tri_Coords:' + str(tri_coords)
        # set triangle indices to generate triangles
        tri_inds = np.array([[0, 0, 1, 1], [1, 1, 2, 3], [2, 3, 5, 5]], dtype = int)
        tri_inds = np.hstack((tri_inds, tri_inds + 3 * np.ones((3, 4), dtype=int), np.array([[6], [7], [8]],dtype=int)))

        print 'Tri_Indices: ' + str(tri_inds)

        s = tri_coords.copy()
        # add 4, expect closet_point_linear to generate equivalent to tri_coords
        s[-1, :] += 4

        print 'Expected points: ' + str(tri_coords)

        c_matching = np.zeros([3, np.shape(s)[1]])
        for i in range(np.shape(s)[1]):
            c = icpm.closest_point_linear(s[:, i], tri_coords, tri_inds)
            c_matching[:, i] = c[:]

        print "Calculated points: " + str(c_matching)

        print "Total linear error: " + str(np.abs(tri_coords - c_matching))
        self.assertTrue(np.all(np.abs(tri_coords - c_matching) <= 1e-4))

        print "Linear tests passed!"


    def icp_tree_test(self):
        """
        Generates a set of triangles and checks that closest_point_tree generates
        same c as closest_point_linear
        Output: if all assertion statements successfully pass
        """
        print "Testing closest_point_tree"
        tri_coords = np.array([[2, 4, 2],[3, 4, 5],[2, 2, 2]], dtype=np.float64)
        to_add = np.array([[4, 4, 4],[ 0, 0, 0], [0, 0, 0]], dtype=np.float64)
        # generate an array of triangle coordinates to build triangles
        for i in range(2):
            tri_coords = np.hstack((tri_coords, tri_coords[:, (-3, -2, -1)] + to_add))

        print 'Tri_Coords:' + str(tri_coords)
        # set triangle indices to generate triangles
        tri_inds = np.array([[0, 0, 1, 1], [1, 1, 2, 3], [2, 3, 5, 5]], dtype=int)
        tri_inds = np.hstack((tri_inds, tri_inds + 3 * np.ones((3, 4), dtype=int), np.array([[6], [7], [8]],dtype=int)))

        print 'Tri_Indices: ' + str(tri_inds)

        s = tri_coords.copy()
        # add 4, expect closet_point_tree to generate equivalent to tri_coords and other methods
        s[-1, :] += 4

        print 'Expected points:' + str(tri_coords)

        c_matching_linear = np.zeros([3, np.shape(s)[1]])
        # generate c estimates using closest_point_linear
        for i in range(np.shape(s)[1]):
            c_linear = icpm.closest_point_linear(s[:, i], tri_coords, tri_inds)
            c_matching_linear[:, i] = c_linear[:]
        print "Linear points: " + str(c_matching_linear)

        triangles = []
        # generate triangles to test covtree
        for i in range(tri_inds.shape[1]):
            t = tr.Triangle(tri_coords[:, tri_inds[:, i]])
            triangles.append(t)
        triangles = np.array(triangles)

        tree = ctn.cov_tree_node(triangles)

        c_matching_tree = np.zeros([3, np.shape(s)[1]])
        c_previous = s + 1000
        old = c_previous
        closest_pts = c_previous
        c_prev = closest_pts[:, i]
        c_error = np.linalg.norm(c_prev - s[:, i])
        closest = [c_prev]
        bound = [c_error]
        tree.find_closest_point_tree(s[:, i], bound, closest)
        c_matching_tree[:, i] = closest[0][:]

        print "Tree points: " + str(c_matching_tree)

        self.assertTrue(np.all(np.abs(c_matching_linear - c_matching_tree) <= 1e-4))
        print 'Tree tests passed!'


    def test_icp_sphere(self):
        """
        Generates a set of triangles and checks that icp_sphere generates same answers
        as icp_linear.
        Output: if all assertion statements successfully pass
        """

        print "Testing closest_point_sphere"
        tri_coords = np.array([[2, 4, 2],[3, 4, 5],[2, 2, 2]], dtype=np.float64)
        to_add = np.array([[4, 4, 4],[ 0, 0, 0], [0, 0, 0]], dtype=np.float64)
        # generate an array of triangle coordinates to build triangles
        for i in range(2):
            tri_coords = np.hstack((tri_coords, tri_coords[:, (-3, -2, -1)] + to_add))

        print 'Tri_Coords:' + str(tri_coords)
        # set triangle indices to generate triangles
        tri_inds = np.array([[0, 0, 1, 1], [1, 1, 2, 3], [2, 3, 5, 5]], dtype=int)
        tri_inds = np.hstack((tri_inds, tri_inds + 3 * np.ones((3, 4), dtype=int), np.array([[6], [7], [8]],dtype=int)))

        print 'Tri_Indices: ' + str(tri_inds)

        s = tri_coords.copy()
        # add 4, expect closet_point_sphere to generate equivalent to tri_coords
        s[-1, :] += 4

        print 'Expected points:' + str(tri_coords)

        # first run linear icp algorithm
        c_matching_linear = np.zeros([3, np.shape(s)[1]])
        for i in range(np.shape(s)[1]):
            c_linear = icpm.closest_point_linear(s[:, i], tri_coords, tri_inds)
            c_matching_linear[:, i] = c_linear[:]
        print "Linear points: " + str(c_matching_linear)

        # then run bounding sphere icp algorithm
        spheres = sphere.create_sphere(tri_coords, tri_inds)
        c_matching_sphere = np.zeros([3, np.shape(s)[1]])
        for i in range(np.shape(s)[1]):
            c_sphere = icpm.closest_point_sphere(s[:, i], tri_coords, tri_inds, spheres)
            c_matching_sphere[:, i] = c_sphere[:]
        print "Sphere points: " + str(c_matching_sphere)

        print "Total sphere error: " + str(np.abs(c_matching_linear - c_matching_sphere))
        self.assertTrue(np.all(np.abs(c_matching_linear - c_matching_sphere) <= 1e-4))
        print 'Sphere tests passed!'



if __name__ == "__main__":
    unittest.main()
