import unittest

import numpy as np
from ICPmatch import icp_get_d, icp_match, get_distance, transform3D, get_inverse, findClosestPoint_brute, get_transform
from ICPread import read_rigid_body, read_sample_readings, read_mesh
import sys
import math

class p3_tests(unittest.TestCase):

    def test_find_b_tip(self, tolerance=1e-2):
        '''
        Tests the find_b_tip method with randomly generated data.
        Output: if all assert statements pass successfully.
        '''

        print("Testing b_pointer tip registration")

        # Random angle generation to create unique rotation matrices
        angles1 = np.random.uniform(0, 2 * np.pi, (3,))
        angles2 = np.random.uniform(0, 2 * np.pi, (3,))

        # Randomly generate rigid body LEDs and A_tip
        a_led = np.random.uniform(0, 10, (6, 3))
        b_led = np.random.uniform(0, 10, (6, 3))
        a_tip = np.random.uniform(0, 10, 3)

        print "a_led: " + str(a_led)
        print "A tip: " + str(a_tip)

        # First, ensure passes for hardcoded rotation and translation values
        r1 = np.array(([1,0,0],
                        [0,1,0],
                        [0,0,1]))
        r2 = np.array(([1,0,0],
                        [0,1,0],
                        [0,0,1]))


        p1 = [1,2,3]
        p2 = [1,2,3]

        # Create frames from rotation and translation
        a_frames = []
        for i in range(6):
            a_frames.append(np.dot(r1, a_led[i]) + p1)
        a_frames = [a_frames]

        print "A Frames: " + str(a_frames)
        b_frames = []
        for i in range(6):
            b_frames.append(np.dot(r2, b_led[i]) + p2)
        b_frames = [b_frames]

        # Test if d_k generated by b_tip method is approximately equal
        d_k = transform3D(get_inverse([r2,p2]),transform3D([r1,p1], a_tip))

        print "d_k: " + str(d_k)

        # Use icp_get_d, compare difference in outputs
        test_d_k = icp_get_d(1, a_frames, b_frames, a_led, b_led, a_tip)
        print "test_d_k: " + str(test_d_k)

        self.assertTrue(np.all(np.abs(d_k - test_d_k) <= tolerance))

        # Generate randomized rotation matrices
        r1 = self.get_rotation(angles1)
        r2 = self.get_rotation(angles2)

        # Generation randomized translation matrixes
        p1 = np.random.uniform(0, 10, 3)
        p2 = np.random.uniform(0, 10, 3)
        print "r1: " + str(r1)

        # Create frames from rotation and translation
        a_frames = []
        for i in range(6):
            a_frames.append(np.dot(r1, a_led[i]) + p1)
        a_frames = [a_frames]

        print "A Frames: " + str(a_frames)
        b_frames = []
        for i in range(6):
            b_frames.append(np.dot(r2, b_led[i]) + p2)
        b_frames = [b_frames]

        # Test if d_k generated by b_tip method is approximately equal
        d_k = transform3D(get_inverse([r2,p2]),transform3D([r1,p1], a_tip))

        print "d_k: " + str(d_k)

        # Use icp_get_d, compare difference in outputs
        test_d_k = icp_get_d(1, a_frames, b_frames, a_led, b_led, a_tip)
        print "test_d_k: " + str(test_d_k)

        self.assertTrue(np.all(np.abs(d_k - test_d_k) <= 50))

        print('Find d_k test passed!')


    def get_rotation(self, angles):
        '''
        Creates a 3D rotation matrix for testing the find b_pointer method
        Inputs: angles -> the rotation angles for x, y, and z
        Output: a generated 3x3 rotation matrix, randomized for each run
        '''
        theta = angles[0]
        phi = angles[1]
        gamma = angles[2]

        rot_x = np.array([[1, 0, 0], [0, np.cos(theta), -np.sin(theta)], [0, np.sin(theta), np.cos(theta)]])
        rot_y = np.array([[np.cos(phi), 0, np.sin(phi)], [0, 1, 0], [-np.sin(phi), 0, np.cos(phi)]])
        rot_z = np.array([[np.cos(gamma), -np.sin(gamma), 0], [np.sin(gamma), np.cos(gamma), 0], [0, 0, 1]])

        return rot_x.dot(rot_y.dot(rot_z))


    def test_find_closest_point(self):
        '''
        With a single triangle, tests the find_closest_point method on a variety
        of input points.
        Output: if all assert statements pass successfully
        '''

        # Simple mesh of a single triangle
        mesh = [[[0, 0, 0], [4, 4, 4], [3, 3, 0]]]
        print "Triangle: " + str(mesh)

        # See if closest point is as expected
        s = [2, 2, 2]
        print "Point: " + str(s)
        test = findClosestPoint_brute(s, mesh)
        print "Closest point: " + str(test)
        self.assertTrue(np.all(np.abs(s - test)) <= 0.1)

        s = [2, 2, 0]
        print "Point: " + str(s)
        test = findClosestPoint_brute(s, mesh)
        print "Closest point: " + str(test)
        self.assertTrue(np.all(np.abs(s - test)) <= 0.1)

        s = [3, 3, 0.5]
        print "Point: " + str(s)
        test = findClosestPoint_brute(s, mesh)
        print "Closest point: " + str(test)
        self.assertTrue(np.all(np.abs(s - test)) <= 1)

        s = [0, 1, 2]
        print "Point: " + str(s)
        test = findClosestPoint_brute(s, mesh)
        print "Closest point: " + str(test)
        self.assertTrue(np.all(np.abs(s - test)) <= 1)


    def test_icp_match_linear(self, tolerance=1e-3):
        """
        Tests linear ICP using a given mesh and specified points to search.
        Input: tolerance, the maximum total error in the results
        Output: if the assertion tests pass successfully
        """
        # Dictionary of vertices to generate triangle mesh
        v = np.array([[1, 2, 0], [3, 3, 0], [1, 4, 0],
             [5, 2, 0], [7, 3, 0], [5, 4, 0],
             [9, 2, 0], [11, 3, 0], [9, 4, 0]])

        print "Vertices: " + str(v)

        # Generate mesh of triangles
        triangles = [[v[0], v[1], v[2]], [v[0], v[1], v[3]],
                     [v[1], v[2], v[5]], [v[1], v[3], v[5]],
                     [v[3], v[4], v[5]], [v[3], v[4], v[6]],
                     [v[4], v[5], v[8]], [v[4], v[6], v[8]],
                     [v[6], v[7], v[8]]]

        print('\nTriangles:')
        print(triangles)

        s = [[1, 2, 4], [3, 3, 4], [1, 4, 4], [5, 2, 4], [7, 3, 4],
             [5, 4, 4], [9, 2, 4], [11, 3, 4], [9, 4, 4]]


        print('\nPoints to search for:')
        print(s)

        print('\nExpected points:')
        print(v)

        # Determine if calculated points are same as expected
        c = icp_match(triangles, s)
        print "Calculated points: " + str(c)

        assert np.all(np.abs(v - c) <= tolerance)

        print('\nLinear ICP tests passed!')



    def test_transform(self):
        '''
        Tests that the get_transform function correctly determines the
        rotation and translation components of the registration.
        '''
        print "Testing get_transform method"
        a = np.array([[5,7,1], [6,3,2], [6,9,1], [1,3,7], [8,5,3]])
        rotation = np.array([[1,0,0], [0,1,0], [0,0,1]])
        translation = np.array([6,3,5])
        ra = np.dot(rotation, a.T)
        b = np.add(ra, np.vstack(translation))
        [R, t] = get_transform(a, b.T)
        self.assertEqual(R.all(), rotation.all())
        self.assertEqual(t.all(), translation.all())
        print "Transform test passed!"



    def test_transform_2(self):
        '''
        Perform get_transform from matrix a to matrix b, as well as from
        matrix b to matrix a. Then, multiply these resultant matrices together
        and add both of their translations. If the resultant matrix is the
        identity, we have verified get_transform is working in both directions.
        '''
        print "Testing get_transform method 2"
        a = np.array([[5,7,1], [6,3,2], [6,9,1], [1,3,7], [8,5,3]])
        rotation = np.array([[1,0,0], [0,1,0], [0,0,1]])
        translation = np.array([6,3,5])
        identity = np.array([[1,0,0], [0,1,0], [0,0,1]])
        ra = np.dot(rotation, a.T)
        b = np.add(ra, np.vstack(translation))
        [R1, t1] = get_transform(a, b.T)
        [R2 ,t2] = get_transform(b.T, a)
        result = np.add(np.add(np.dot(R1, R2), t1), t2)
        self.assertEqual(result.all(), identity.all())
        print "Transform test 2 passed!"


if __name__ == "__main__":
    unittest.main()
